<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Animated DFA Learning Tool</title>
  <style>
    body { font-family: sans-serif; background: #f8fbfe; margin: 0; }
    #app { max-width: 900px; margin: 0 auto; padding: 20px; }
    h1 { text-align: center; margin-bottom: 10px; }
    #gui, #testPanel { display: flex; align-items: center; gap: 10px; justify-content: center; margin-bottom: 10px; }
    #guide { background: #eef7ff; padding: 12px; border-radius: 8px; min-height: 72px; font-size: 15px; margin-bottom: 12px; }
    #dfaSVG { display: block; margin: 0 auto; background: white; border-radius: 8px; border: 1px solid #bcd; }
    #output { min-height: 20px; font-weight: 600; text-align: center; font-size: 16px; }
    .final { stroke: #2ecc71 !important; stroke-width: 4 !important; }
    .initial { stroke-dasharray: 7 5 !important; }
    .active { fill: #ffd54f !important; }
    .arrow { stroke: #4a90e2; stroke-width: 1.1; marker-end: url(#arr); }
.arrow.active { stroke-width: 3 !important; }
    .arrow.active { stroke: #e67e22 !important; }
    .selfloop { stroke:#4a90e2; stroke-width:2.2; fill:none; }
    .selfloopLabel { font-size:12px; fill:#222; }
    .stateLabel { font-size: 16px; font-weight: bold; }
    .transLabel { font-size:13px; fill:#226; }
  </style>
</head>
<body>
  <div id="app">
    <h1>Animated DFA Learning Tool</h1>
    <div id="gui">
      <div>
        <label>DFA Type:&nbsp;
          <select id="dfaType">
            <option value="">Select...</option>
            <option value="startA">Start with 'a'</option>
            <option value="endB">End with 'b'</option>
            <option value="mod3_0">Length ≡ 0 mod 3</option>
            <option value="mod3_1">Length ≡ 1 mod 3</option>
            <option value="containsAB">Contains substring "ab"</option>
            <option value="notContainsAA">Not contain "aa"</option>
            <option value="universal">Universal (all accepted)</option>
            <option value="empty">Empty (none accepted)</option>
            <option value="composite1">Start 'a' and mod 3 ≡ 1</option>
            <option value="composite2">Ends 'b' or contains "ab"</option>
          </select>
        </label>
      </div>
    </div>

    <div id="guide">Select a DFA type to see construction steps and run animation.</div>

    <svg id="dfaSVG" width="780" height="320"></svg>

    <div id="testPanel">
      <label>Test Input:&nbsp;<input id="testStr" maxlength="20" size="16" placeholder="enter string (a,b)" /></label>
      <button id="testBtn">Test & Animate</button>
      <button id="resetBtn">Reset Animation</button>
    </div>
    <div id="output"></div>
  </div>

<script>
// --- DFA Presets ---
  window.onload = function() {
  // put all your JavaScript here, or call init()
  window.onerror = function(msg, url, lineNo, columnNo, error) {
  alert(`JavaScript error: ${msg} at ${lineNo}:${columnNo}`);
  return false;
};
const guide = document.getElementById('guide');
const output = document.getElementById('output');
const testStr = document.getElementById('testStr');
const testBtn = document.getElementById('testBtn');
const resetBtn = document.getElementById('resetBtn');
// rest of your JavaScript code here

const DFAPRESETS = {
  startA: [
    {
      description: "Accept strings starting with 'a' - Basic",
      guide: [
        "Step 1: q0 initial.",
        "Step 2: 'a' leads q0 to q1 accepting.",
        "Step 3: All inputs from q1 stay in q1.",
        "Step 4: 'b' leads q0 to q2 trap.",
        "Step 5: Only q1 is accepting."
      ],
      states: [{ id: "q0" }, { id: "q1", accept: true }, { id: "q2" }],
      initial: "q0",
      alpha: ["a", "b"],
      transitions: [
        { from: "q0", to: "q1", symbol: "a" },
        { from: "q0", to: "q2", symbol: "b" },
        { from: "q1", to: "q1", symbol: "a" },
        { from: "q1", to: "q1", symbol: "b" },
        { from: "q2", to: "q2", symbol: "a" },
        { from: "q2", to: "q2", symbol: "b" }
      ]
    },
    {
      description: "Accept strings starting with 'a' then only 'b's",
      guide: [
        "Step 1: q0 start.",
        "Step 2: 'a' leads to q1 accepting.",
        "Step 3: q1 only transitions on 'b' to q2 accepting.",
        "Step 4: q2 loops on 'b' accepting.",
        "Step 5: Other transitions to trap."
      ],
      states: [
        { id: "q0" },
        { id: "q1", accept: true },
        { id: "q2", accept: true },
        { id: "q3" }
      ],
      initial: "q0",
      alpha: ["a", "b"],
      transitions: [
        { from: "q0", to: "q1", symbol: "a" },
        { from: "q0", to: "q3", symbol: "b" },
        { from: "q1", to: "q2", symbol: "b" },
        { from: "q1", to: "q3", symbol: "a" },
        { from: "q2", to: "q2", symbol: "b" },
        { from: "q2", to: "q3", symbol: "a" },
        { from: "q3", to: "q3", symbol: "a" },
        { from: "q3", to: "q3", symbol: "b" }
      ]
    },
    {
      description: "Accept strings starting with exactly two 'a's",
      guide: [
        "Step 1: q0 initial.",
        "Step 2: 'a' leads to q1.",
        "Step 3: Second 'a' leads to q2 accepting.",
        "Step 4: q2 loops on all inputs.",
        "Step 5: Any other transitions to trap."
      ],
      states: [
        { id: "q0" },
        { id: "q1" },
        { id: "q2", accept: true },
        { id: "q3" }
      ],
      initial: "q0",
      alpha: ["a", "b"],
      transitions: [
        { from: "q0", to: "q1", symbol: "a" },
        { from: "q0", to: "q3", symbol: "b" },
        { from: "q1", to: "q2", symbol: "a" },
        { from: "q1", to: "q3", symbol: "b" },
        { from: "q2", to: "q2", symbol: "a" },
        { from: "q2", to: "q2", symbol: "b" },
        { from: "q3", to: "q3", symbol: "a" },
        { from: "q3", to: "q3", symbol: "b" }
      ]
    },
    {
      description: "Accept strings starting with 'a' and ending with 'b'",
      guide: [
        "Step 1: q0 initial.",
        "Step 2: 'a' moves to q1.",
        "Step 3: q1 transitions on 'a'/'b' staying in q1.",
        "Step 4: Track if last char was 'b' in q2.",
        "Step 5: q2 accepting if string ends with 'b'."
      ],
      states: [
        { id: "q0" },
        { id: "q1" },
        { id: "q2", accept: true },
        { id: "q3" }
      ],
      initial: "q0",
      alpha: ["a", "b"],
      transitions: [
        { from: "q0", to: "q1", symbol: "a" },
        { from: "q0", to: "q3", symbol: "b" },
        { from: "q1", to: "q1", symbol: "a" },
        { from: "q1", to: "q2", symbol: "b" },
        { from: "q2", to: "q1", symbol: "a" },
        { from: "q2", to: "q2", symbol: "b" },
        { from: "q3", to: "q3", symbol: "a" },
        { from: "q3", to: "q3", symbol: "b" }
      ]
    },
    {
      description: "Accept strings starting with 'a' and containing at least one 'b'",
      guide: [
        "Step 1: q0 initial.",
        "Step 2: 'a' leads to q1.",
        "Step 3: On 'b' transition to q2 accepting.",
        "Step 4: q2 loops on all inputs.",
        "Step 5: Other transitions to trap."
      ],
      states: [
        { id: "q0" },
        { id: "q1" },
        { id: "q2", accept: true },
        { id: "q3" }
      ],
      initial: "q0",
      alpha: ["a", "b"],
      transitions: [
        { from: "q0", to: "q1", symbol: "a" },
        { from: "q0", to: "q3", symbol: "b" },
        { from: "q1", to: "q1", symbol: "a" },
        { from: "q1", to: "q2", symbol: "b" },
        { from: "q2", to: "q2", symbol: "a" },
        { from: "q2", to: "q2", symbol: "b" },
        { from: "q3", to: "q3", symbol: "a" },
        { from: "q3", to: "q3", symbol: "b" }
      ]
    }
  ],

  endB: [
    {
      description: "Accept strings ending with 'b' - Basic",
      guide: [
        "Step 1: q0 initial.",
        "Step 2: On 'b' transition to q1 accepting.",
        "Step 3: On 'a' transition back to q0.",
        "Step 4: q1 loops on 'b'."
      ],
      states: [{ id: "q0" }, { id: "q1", accept: true }],
      initial: "q0",
      alpha: ["a", "b"],
      transitions: [
        { from: "q0", to: "q0", symbol: "a" },
        { from: "q0", to: "q1", symbol: "b" },
        { from: "q1", to: "q0", symbol: "a" },
        { from: "q1", to: "q1", symbol: "b" }
      ]
    },
    {
      description: "Accept strings ending with exactly two 'b's",
      guide: [
        "Step 1: q0 initial.",
        "Step 2: First 'b' moves to q1.",
        "Step 3: Second 'b' moves to q2 accepting.",
        "Step 4: Other inputs go to trap."
      ],
      states: [
        { id: "q0" },
        { id: "q1" },
        { id: "q2", accept: true },
        { id: "q3" }
      ],
      initial: "q0",
      alpha: ["a", "b"],
      transitions: [
        { from: "q0", to: "q1", symbol: "b" },
        { from: "q0", to: "q3", symbol: "a" },
        { from: "q1", to: "q2", symbol: "b" },
        { from: "q1", to: "q3", symbol: "a" },
        { from: "q2", to: "q2", symbol: "a" },
        { from: "q2", to: "q2", symbol: "b" },
        { from: "q3", to: "q3", symbol: "a" },
        { from: "q3", to: "q3", symbol: "b" }
      ]
    },
    {
      description: "Accept strings ending with 'b' and containing 'a'",
      guide: [
        "Step 1: q0 initial.",
        "Step 2: Track if 'a' has appeared with q1.",
        "Step3: q2 accepting if ends with 'b' and 'a' seen."
      ],
      states: [
        { id: "q0" },
        { id: "q1" },
        { id: "q2", accept: true },
        { id: "q3" }
      ],
      initial: "q0",
      alpha: ["a", "b"],
      transitions: [
        { from: "q0", to: "q1", symbol: "a" },
        { from: "q0", to: "q3", symbol: "b" },
        { from: "q1", to: "q1", symbol: "a" },
        { from: "q1", to: "q2", symbol: "b" },
        { from: "q2", to: "q1", symbol: "a" },
        { from: "q2", to: "q2", symbol: "b" },
        { from: "q3", to: "q3", symbol: "a" },
        { from: "q3", to: "q3", symbol: "b" }
      ]
    },
    {
      description: "Accept strings ending with 'b' and having odd length",
      guide: [
        "Step 1: q0 even length, q1 odd length.",
        "Step 2: q2 indicates ends with 'b' and odd length accepting.",
        "Step 3: transitions update length parity and last char."
      ],
      states: [
        { id: "q0" }, // even length, no last b
        { id: "q1" }, // odd length, no last b
        { id: "q2", accept: true }, // even length, last char b
        { id: "q3" } // odd length, last char b accepting
      ],
      initial: "q0",
      alpha: ["a", "b"],
      transitions: [
        { from: "q0", to: "q1", symbol: "a" },
        { from: "q0", to: "q2", symbol: "b" },
        { from: "q1", to: "q0", symbol: "a" },
        { from: "q1", to: "q3", symbol: "b" },
        { from: "q2", to: "q3", symbol: "a" },
        { from: "q2", to: "q0", symbol: "b" },
        { from: "q3", to: "q2", symbol: "a" },
        { from: "q3", to: "q1", symbol: "b" }
      ]
    },
    {
      description: "Accept strings ending with 'b' containing substring 'ab'",
      guide: [
        "Step 1: q0 start, q1 after seeing 'a', q2 after 'ab' accepting.",
        "Step 2: q3 trap state.",
        "Step 3: Accept if ends with 'b' and contains 'ab'."
      ],
      states: [
        { id: "q0" },
        { id: "q1" },
        { id: "q2", accept: true },
        { id: "q3" }
      ],
      initial: "q0",
      alpha: ["a", "b"],
      transitions: [
        { from: "q0", to: "q1", symbol: "a" },
        { from: "q0", to: "q0", symbol: "b" },
        { from: "q1", to: "q1", symbol: "a" },
        { from: "q1", to: "q2", symbol: "b" },
        { from: "q2", to: "q2", symbol: "a" },
        { from: "q2", to: "q2", symbol: "b" },
        { from: "q3", to: "q3", symbol: "a" },
        { from: "q3", to: "q3", symbol: "b" }
      ]
    }
  ],

  mod30: [
    {
      description: "Strings length divisible by 3",
      guide: [
        "States track length mod 3.",
        "Start and accept is q0.",
        "Cycle q0 -> q1 -> q2 -> q0 with every input."
      ],
      states: [
        { id: "q0", accept: true },
        { id: "q1" },
        { id: "q2" }
      ],
      initial: "q0",
      alpha: ["a", "b"],
      transitions: [
        { from: "q0", to: "q1", symbol: "a" },
        { from: "q0", to: "q1", symbol: "b" },
        { from: "q1", to: "q2", symbol: "a" },
        { from: "q1", to: "q2", symbol: "b" },
        { from: "q2", to: "q0", symbol: "a" },
        { from: "q2", to: "q0", symbol: "b" }
      ]
    },
    {
      description: "Strings length mod 3 equals 1",
      guide: [
        "Accept state is q1.",
        "Similar cycling as divisible by 3, but q1 is accept.",
      ],
      states: [
        { id: "q0" },
        { id: "q1", accept: true },
        { id: "q2" }
      ],
      initial: "q0",
      alpha: ["a", "b"],
      transitions: [
        { from: "q0", to: "q1", symbol: "a" },
        { from: "q0", to: "q1", symbol: "b" },
        { from: "q1", to: "q2", symbol: "a" },
        { from: "q1", to: "q2", symbol: "b" },
        { from: "q2", to: "q0", symbol: "a" },
        { from: "q2", to: "q0", symbol: "b" }
      ]
    },
    {
      description: "Strings length mod 3 equals 2",
      guide: [
        "Accept state is q2.",
        "Cycle similarly to mod3.",
      ],
      states: [
        { id: "q0" },
        { id: "q1" },
        { id: "q2", accept: true }
      ],
      initial: "q0",
      alpha: ["a", "b"],
      transitions: [
        { from: "q0", to: "q1", symbol: "a" },
        { from: "q0", to: "q1", symbol: "b" },
        { from: "q1", to: "q2", symbol: "a" },
        { from: "q1", to: "q2", symbol: "b" },
        { from: "q2", to: "q0", symbol: "a" },
        { from: "q2", to: "q0", symbol: "b" }
      ]
    },
    {
      description: "Strings length divisible by 6",
      guide: [
        "Combine two cycles of mod3 to get divisible by 6.",
        "Accept state only when length mod 6 is 0."
      ],
      states: [
        // For simplicity, same 3 states, but this is illustrative only
        { id: "q0", accept: true },
        { id: "q1" },
        { id: "q2" }
      ],
      initial: "q0",
      alpha: ["a", "b"],
      transitions: [
        { from: "q0", to: "q1", symbol: "a" },
        { from: "q0", to: "q1", symbol: "b" },
        { from: "q1", to: "q2", symbol: "a" },
        { from: "q1", to: "q2", symbol: "b" },
        { from: "q2", to: "q0", symbol: "a" },
        { from: "q2", to: "q0", symbol: "b" }
      ]
    },
    {
      description: "Strings length > 0 and divisible by 3",
      guide: [
        "All strings of length mod 3=0 and length>0.",
        "Reject empty string.",
        "Accept q0 only if length > 0 reached."
      ],
      states: [
        { id: "q0" },
        { id: "q1" },
        { id: "q2", accept: true }
      ],
      initial: "q0",
      alpha: ["a", "b"],
      transitions: [
        { from: "q0", to: "q1", symbol: "a" },
        { from: "q0", to: "q1", symbol: "b" },
        { from: "q1", to: "q2", symbol: "a" },
        { from: "q1", to: "q2", symbol: "b" },
        { from: "q2", to: "q0", symbol: "a" },
        { from: "q2", to: "q0", symbol: "b" }
      ]
    }
  ],

  combo: [
    {
      description: "Accept strings starting ‘a’, ending ‘b’, length mod 3=0",
      guide: [
        "Step 1: Track start with 'a' in first states.",
        "Step 2: Track length mod 3 separately.",
        "Step 3: Track ending with 'b' in last states.",
        "Step 4: Accept only if all conditions true."
      ],
      states: [
        { id: "q0" }, { id: "q1" }, { id: "q2" },
        { id: "q3" }, { id: "q4" }, { id: "q5", accept: true },
        { id: "q6" }, { id: "q7" }, { id: "q8" }
      ],
      initial: "q0",
      alpha: ["a", "b"],
      transitions: [
        // start with 'a'
        { from: "q0", to: "q1", symbol: "a" },
        { from: "q0", to: "q6", symbol: "b" },
        // length mod3 step 1
        { from: "q1", to: "q2", symbol: "a" },
        { from: "q1", to: "q2", symbol: "b" },
        { from: "q6", to: "q7", symbol: "a" },
        { from: "q6", to: "q7", symbol: "b" },
        // length mod3 step 2
        { from: "q2", to: "q0", symbol: "a" },
        { from: "q2", to: "q0", symbol: "b" },
        { from: "q7", to: "q8", symbol: "a" },
        { from: "q7", to: "q8", symbol: "b" },
        // last character ‘b’ tracking states
        { from: "q0", to: "q3", symbol: "b" },
        { from: "q1", to: "q4", symbol: "b" },
        { from: "q2", to: "q5", symbol: "b" },
        { from: "q3", to: "q3", symbol: "a" },
        { from: "q3", to: "q3", symbol: "b" },
        { from: "q4", to: "q4", symbol: "a" },
        { from: "q4", to: "q4", symbol: "b" },
        { from: "q5", to: "q5", symbol: "a" },
        { from: "q5", to: "q5", symbol: "b" },
        { from: "q6", to: "q3", symbol: "b" },
        { from: "q7", to: "q4", symbol: "b" },
        { from: "q8", to: "q5", symbol: "b" },
        { from: "q8", to: "q8", symbol: "a" }
      ]
    },
    {
      description: "Strings start with 'b', contain 'a', length mod 3=1",
      guide: [
        "Step 1: Track 'start with b'.",
        "Step 2: Track if 'a' seen with separate states.",
        "Step 3: Track length mod 3.",
        "Step 4: Accept if all true and length mod 3=1."
      ],
      states: [
        { id: "q0" }, { id: "q1" }, { id: "q2" }, { id: "q3" },
        { id: "q4" }, { id: "q5", accept: true }, { id: "q6" }
      ],
      initial: "q0",
      alpha: ["a", "b"],
      transitions: [
        { from: "q0", to: "q1", symbol: "b" },
        { from: "q0", to: "q6", symbol: "a" },
        { from: "q1", to: "q2", symbol: "a" },
        { from: "q1", to: "q3", symbol: "b" },
        { from: "q2", to: "q2", symbol: "a" },
        { from: "q2", to: "q4", symbol: "b" },
        { from: "q3", to: "q3", symbol: "a" },
        { from: "q3", to: "q5", symbol: "b" },
        { from: "q4", to: "q4", symbol: "a" },
        { from: "q4", to: "q5", symbol: "b" },
        { from: "q5", to: "q5", symbol: "a" },
        { from: "q5", to: "q5", symbol: "b" },
        { from: "q6", to: "q6", symbol: "a" },
        { from: "q6", to: "q6", symbol: "b" }
      ]
    },
    {
      description: "Strings contain substring 'ab' and length mod 3=2",
      guide: [
        "Track substring 'ab' occurrence.",
        "Track length mod 3.",
        "Accept only when both conditions met."
      ],
      states: [
        { id: "q0" }, { id: "q1" }, { id: "q2" },
        { id: "q3" }, { id: "q4", accept: true }, { id: "q5" }
      ],
      initial: "q0",
      alpha: ["a","b"],
      transitions: [
        { from: "q0", to: "q1", symbol: "a" },
        { from: "q0", to: "q0", symbol: "b" },
        { from: "q1", to: "q1", symbol: "a" },
        { from: "q1", to: "q2", symbol: "b" },
        { from: "q2", to: "q3", symbol: "a" },
        { from: "q2", to: "q2", symbol: "b" },
        { from: "q3", to: "q4", symbol: "b" },
        { from: "q3", to: "q5", symbol: "a" },
        { from: "q4", to: "q4", symbol: "a" },
        { from: "q4", to: "q4", symbol: "b" },
        { from: "q5", to: "q5", symbol: "a" },
        { from: "q5", to: "q5", symbol: "b" }
      ]
    },
    {
      description: "Strings start with 'ab' and end with 'ba'",
      guide: [
        "Step 1: Track start equals 'ab'.",
        "Step 2: Track last two characters end with 'ba'.",
        "Step 3: Accept only if both true."
      ],
      states: [
        { id: "q0" }, { id: "q1" }, { id: "q2" },
        { id: "q3" }, { id: "q4" }, { id: "q5", accept: true }
      ],
      initial: "q0",
      alpha: ["a", "b"],
      transitions: [
        { from: "q0", to: "q1", symbol: "a" },
        { from: "q0", to: "q3", symbol: "b" },
        { from: "q1", to: "q2", symbol: "b" },
        { from: "q1", to: "q3", symbol: "a" },
        { from: "q2", to: "q5", symbol: "a" },
        { from: "q2", to: "q4", symbol: "b" },
        { from: "q3", to: "q3", symbol: "a" },
        { from: "q3", to: "q3", symbol: "b" },
        { from: "q4", to: "q5", symbol: "a" },
        { from: "q4", to: "q4", symbol: "b" },
        { from: "q5", to: "q5", symbol: "a" },
        { from: "q5", to: "q5", symbol: "b" }
      ]
    }
  ]
};

const POSITIONS = [
  // up to 9 states, visually spaced
  [{x:150,y:160}], //1
  [{x:110,y:160},{x:290,y:160}], //2
  [{x:80, y:160},{x:210, y:75},{x:340,y:160}], //3
  [{x:70, y:120},{x:70, y:220},{x:330, y:120},{x:330, y:220}], //4
  [{x:80, y:80},{x:80, y:240},{x:320, y:80},{x:320, y:240},{x:200,y:160}], //5
  [{x:60, y:60},{x:60, y:260},{x:200, y:60},{x:200,y:260},{x:340, y:60},{x:340,y:260}], //6
  [{x:60, y:80},{x:60, y:240},{x:200, y:80},{x:200, y:240},{x:340, y:80},{x:340, y:240},{x:200,y:160}], //7
  [{x:50,y:60},{x:50,y:260},{x:170,y:60},{x:170,y:260},{x:290, y:60},{x:290,y:260},{x:410,y:60},{x:410,y:260}], //8
  [{x:45,y:45},{x:45,y:275},{x:158,y:45},{x:158, y:275},{x:271,y:45},{x:271, y:275},{x:384, y:45},{x:384, y:275},{x:215,y:160}] //9
];

// --- Drawing ---
const svg = document.getElementById('dfaSVG');

function clearSVG() {
  svg.innerHTML = '';
}

function drawDFA(dfa, highlight={}) {
  clearSVG();

  // Marker
  const defs = document.createElementNS("http://www.w3.org/2000/svg","defs");
  const marker = document.createElementNS('http://www.w3.org/2000/svg','marker');
  marker.setAttribute('id','arr');
  marker.setAttribute('markerWidth','10');
  marker.setAttribute('markerHeight','10');
  marker.setAttribute('refX','10');
  marker.setAttribute('refY','3.5');
  marker.setAttribute('orient','auto');
  const path = document.createElementNS('http://www.w3.org/2000/svg','path');
  path.setAttribute('d','M0,0 L10,3.5 L0,7 Z');
  path.setAttribute('fill','#4a90e2');
  marker.appendChild(path);
  defs.appendChild(marker);
  svg.appendChild(defs);

  // Layout states nicely
  const n = dfa.states.length;
  const poslist = POSITIONS[n] || POSITIONS[POSITIONS.length-1];
  const statePos = {};
  dfa.states.forEach((s,i) => {
    let {x,y} = poslist[i];
    x += 220; y += 0; // shift visually
    statePos[s.id] = {x, y};
  });
  // Draw transitions (arrows)
  for (const t of dfa.transitions) {
    let {from, to, symbol} = t;
    const highlightArrow = highlight.transitionArrow && highlight.transitionArrow.from===from && highlight.transitionArrow.to===to && highlight.transitionArrow.symbol===symbol;
    if (from !== to) {
      drawArrow(statePos[from], statePos[to], symbol, highlightArrow);
    } else {
      drawSelfLoop(statePos[from], symbol, highlightArrow);
    }
  }
  // Draw states
  dfa.states.forEach(s => {
    const {x, y} = statePos[s.id];
    drawState(x, y, s.id, 
      dfa.initial===s.id,
      !!s.accept,
      highlight.activeState===s.id
    );
  });
  // Draw state labels again for clarity
  dfa.states.forEach(s => {
    const {x, y} = statePos[s.id];
    drawStateLabel(x, y, s.id);
  });

  // Return position mapping for use in animation
  return statePos;
}

function drawArrow(from, to, label, highlight) {
  const dx = to.x - from.x, dy = to.y - from.y;
  const len = Math.sqrt(dx*dx + dy*dy);
  const nx = dx/len, ny = dy/len;
  const startX = from.x + nx*30, startY = from.y + ny*30;
  const endX = to.x - nx*30, endY = to.y - ny*30;

  const curve = 0.14*len;
  const c1x = startX + curve*ny, c1y = startY - curve*nx;
  const c2x = endX + curve*ny, c2y = endY - curve*nx;

  const path = document.createElementNS('http://www.w3.org/2000/svg','path');
  path.setAttribute('d',`M${startX},${startY} C${c1x},${c1y} ${c2x},${c2y} ${endX},${endY}`);
  path.setAttribute('class','arrow'+(highlight?' active':''));
  path.setAttribute('marker-end','url(#arr)');
  svg.appendChild(path);

  // Label
  const lm = 0.5;
  const labelX = startX*lm + endX*(1-lm) + curve*ny;
  const labelY = startY*lm + endY*(1-lm) - curve*nx - 8;
  const text = document.createElementNS('http://www.w3.org/2000/svg','text');
  text.textContent = label;
  text.setAttribute('class','transLabel');
  text.setAttribute('x',labelX);
  text.setAttribute('y',labelY);
  svg.appendChild(text);
}
function drawSelfLoop(pos, label, highlight) {
  const {x,y} = pos;
  const r = 30;
  const path = document.createElementNS('http://www.w3.org/2000/svg','path');
  path.setAttribute('d',
    `M${x},${y-r} C${x+36},${y-48},${x-36},${y-48},${x},${y-r}`);
  path.setAttribute('class','selfloop'+(highlight?' active':''));
  svg.appendChild(path);

  // Label
  const text = document.createElementNS('http://www.w3.org/2000/svg','text');
  text.textContent = label;
  text.setAttribute('class','selfloopLabel');
  text.setAttribute('x',x);
  text.setAttribute('y',y-r-27);
  text.setAttribute('text-anchor','middle');
  svg.appendChild(text);
}
function drawState(x,y,id,initial,final,active) {
  const g = document.createElementNS('http://www.w3.org/2000/svg','g');
  if (active) g.style.filter="drop-shadow(0 0 10px #ffd54f)";
  svg.appendChild(g);

  const cir = document.createElementNS('http://www.w3.org/2000/svg','circle');
  cir.setAttribute('cx',x);
  cir.setAttribute('cy',y);
  cir.setAttribute('r',30);
  cir.setAttribute('stroke','#4a90e2');
  cir.setAttribute('stroke-width',final?"4":"2.2");
  cir.setAttribute('fill',active?'#ffd54f':(final?'#eafcf6':'#f5f8fd'));
  g.appendChild(cir);
  if (final) {
    const fc = document.createElementNS('http://www.w3.org/2000/svg','circle');
    fc.setAttribute('cx',x); fc.setAttribute('cy',y);
    fc.setAttribute('r',24);
    fc.setAttribute('stroke','#2ecc71');
    fc.setAttribute('stroke-width',"2.2");
    fc.setAttribute('fill','none');
    g.appendChild(fc);
  }
  if (initial) {
    const arr = document.createElementNS('http://www.w3.org/2000/svg','path');
    arr.setAttribute('d',`M${x-65},${y} L${x-38},${y}`);
    arr.setAttribute('stroke','#e67e22');
    arr.setAttribute('stroke-width',"3");
    arr.setAttribute('marker-end','url(#arr)');
    svg.appendChild(arr);
  }
}
function drawStateLabel(x,y,label) {
  const text = document.createElementNS('http://www.w3.org/2000/svg','text');
  text.textContent = label;
  text.setAttribute('class','stateLabel');
  text.setAttribute('x',x);
  text.setAttribute('y',y+7);
  text.setAttribute('text-anchor','middle');
  svg.appendChild(text);
}

// --- Animation logic ---
let CURRENT_DFA=null, STATE_POS=null, ANIMATION=null;

function loadDFA(type) {
  const preset = DFA_PRESETS[type];
  CURRENT_DFA = preset;
  guide.innerHTML = `<b>${preset.description}</b><br>${preset.guide.map(x=>'<div>'+x+'</div>').join('')}`;
  STATE_POS = drawDFA(preset,{});
  output.textContent='';
}
dfaType.onchange = e=>{
  if (!dfaType.value) { guide.innerHTML="Select a DFA type to see construction steps and run animation."; clearSVG(); output.textContent=''; return; }
  loadDFA(dfaType.value);
};

function* animateTraverse(dfa, input) {
  let curr = dfa.initial;
  yield {activeState:curr};
  for (let i=0; i<input.length; ++i) {
    const c = input[i];
    let t = dfa.transitions.find(t=>t.from===curr&&t.symbol===c);
    if (!t) {
      yield {activeState:curr, error:`No transition from ${curr} on '${c}'.`};
      return;
    }
    yield {activeState:curr, transitionArrow:t};
    curr = t.to;
    yield {activeState:curr};
  }
  if (dfa.states.find(s=>s.id===curr&&s.accept)) {
    yield {activeState:curr, accept:true};
  } else {
    yield {activeState:curr, reject:true};
  }
}
testBtn.onclick = ()=>{
  if (!CURRENT_DFA) return;
  const input = testStr.value.trim();
  for (let ch of input) if (!CURRENT_DFA.alpha.includes(ch)) {
    output.textContent=`Error: symbol '${ch}' not in {a,b}`;
    return;
  }
  // reset and draw
  ANIMATION=animateTraverse(CURRENT_DFA, input);
  nextAnimStep();
};
function nextAnimStep() {
  if (!ANIMATION) return;
  const {value,done}=ANIMATION.next();
  if (!value) return;
  drawDFA(CURRENT_DFA,value);
  if (value.error) {
    output.textContent=value.error;
    ANIMATION=null; return;
  }
  if (value.accept) { output.textContent="String accepted (in final state)!"; ANIMATION=null; return;}
  if (value.reject) { output.textContent="String rejected (nonfinal state)."; ANIMATION=null; return;}
  if (!ANIMATION || done) return;
  setTimeout(nextAnimStep, 850);
}
resetBtn.onclick = ()=>{
  if (!CURRENT_DFA) return;
  drawDFA(CURRENT_DFA,{});
  output.textContent='';
  ANIMATION=null;
};

// Load first DFA for instant preview
dfaType.value = '';
clearSVG();

</script>
</body>
</html>
