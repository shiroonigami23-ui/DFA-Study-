<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Animated DFA Learning Tool</title>
  <style>
    body { font-family: sans-serif; background: #f8fbfe; margin: 0; }
    #app { max-width: 900px; margin: 0 auto; padding: 20px; }
    h1 { text-align: center; margin-bottom: 10px; }
    #gui, #testPanel { display: flex; align-items: center; gap: 10px; justify-content: center; margin-bottom: 10px; }
    #guide { background: #eef7ff; padding: 12px; border-radius: 8px; min-height: 72px; font-size: 15px; margin-bottom: 12px; }
    #dfaSVG { display: block; margin: 0 auto; background: white; border-radius: 8px; border: 1px solid #bcd; }
    #output { min-height: 20px; font-weight: 600; text-align: center; font-size: 16px; }
    .final { stroke: #2ecc71 !important; stroke-width: 4 !important; }
    .initial { stroke-dasharray: 7 5 !important; }
    .active { fill: #ffd54f !important; }
    .arrow { stroke: #4a90e2; stroke-width: 1.1; marker-end: url(#arr); }
.arrow.active { stroke-width: 3 !important; }
    .arrow.active { stroke: #e67e22 !important; }
    .selfloop { stroke:#4a90e2; stroke-width:2.2; fill:none; }
    .selfloopLabel { font-size:12px; fill:#222; }
    .stateLabel { font-size: 16px; font-weight: bold; }
    .transLabel { font-size:13px; fill:#226; }
  </style>
</head>
<body>
  <div id="app">
    <h1>Animated DFA Learning Tool</h1>
    <div id="gui">
      <div>
        <label>DFA Type:&nbsp;
          <select id="dfaType">
            <option value="">Select...</option>
            <option value="startA">Start with 'a'</option>
            <option value="endB">End with 'b'</option>
            <option value="mod3_0">Length ≡ 0 mod 3</option>
            <option value="mod3_1">Length ≡ 1 mod 3</option>
            <option value="containsAB">Contains substring "ab"</option>
            <option value="notContainsAA">Not contain "aa"</option>
            <option value="universal">Universal (all accepted)</option>
            <option value="empty">Empty (none accepted)</option>
            <option value="composite1">Start 'a' and mod 3 ≡ 1</option>
            <option value="composite2">Ends 'b' or contains "ab"</option>
          </select>
        </label>
      </div>
    </div>

    <div id="guide">Select a DFA type to see construction steps and run animation.</div>

    <svg id="dfaSVG" width="780" height="320"></svg>

    <div id="testPanel">
      <label>Test Input:&nbsp;<input id="testStr" maxlength="20" size="16" placeholder="enter string (a,b)" /></label>
      <button id="testBtn">Test & Animate</button>
      <button id="resetBtn">Reset Animation</button>
    </div>
    <div id="output"></div>
  </div>

<script>
// --- DFA Presets ---
  window.onload = function() {
  // put all your JavaScript here, or call init()
  window.onerror = function(msg, url, lineNo, columnNo, error) {
  alert(`JavaScript error: ${msg} at ${lineNo}:${columnNo}`);
  return false;
};
const guide = document.getElementById('guide');
const output = document.getElementById('output');
const testStr = document.getElementById('testStr');
const testBtn = document.getElementById('testBtn');
const resetBtn = document.getElementById('resetBtn');
// rest of your JavaScript code here
const DFA_PRESETS = {
  startA: {
    description: `Accept strings that start with 'a' (alphabet {a,b})`,
    guide: [
      "Step 1: States q0 (start), q1 (read 'a' first), q2 (read 'b' first; trap).",
      "Step 2: q0 is initial.",
      "Step 3: 'a' from q0 → q1 (accept), 'b' from q0 → q2 (trap).",
      "Step 4: All input from q1 stays in q1. q2 is a sink on any input.",
      "Step 5: Only q1 is accepting."
    ],
    states: [{id:'q0'},{id:'q1',accept:1},{id:'q2'}],
    initial: 'q0',
    alpha: ['a','b'],
    transitions: [
      {from:'q0', to:'q1', symbol:'a'}, {from:'q0', to:'q2', symbol:'b'},
      {from:'q1', to:'q1', symbol:'a'}, {from:'q1', to:'q1', symbol:'b'},
      {from:'q2', to:'q2', symbol:'a'}, {from:'q2', to:'q2', symbol:'b'}
    ]
  },
  endB: {
    description: `Accept strings ending with 'b'.`,
    guide: [
      "Step 1: States q0 (not ending with b yet), q1 (last char was b).",
      "Step 2: q0 initial. On 'b', go to q1; on 'a', back to q0.",
      "Step 3: q1 is accepting (string ends with b)."
    ],
    states: [{id:'q0'},{id:'q1',accept:1}],
    initial: 'q0',
    alpha: ['a','b'],
    transitions: [
      {from:'q0',to:'q0',symbol:'a'},{from:'q0',to:'q1',symbol:'b'},
      {from:'q1',to:'q0',symbol:'a'},{from:'q1',to:'q1',symbol:'b'}
    ]
  },
  mod3_0: {
    description: `Accept all strings of length divisible by 3.`,
    guide: [
      "Step 1: States q0 (length 0 mod 3), q1 (1 mod 3), q2 (2 mod 3).",
      "Step 2: q0 is start/accept. On each input move to next mod-3 state.",
      "Step 3: Accept only in q0."
    ],
    states: [{id:'q0',accept:1},{id:'q1'},{id:'q2'}],
    initial: 'q0',
    alpha: ['a','b'],
    transitions:[
      {from:'q0',to:'q1',symbol:'a'},{from:'q0',to:'q1',symbol:'b'},
      {from:'q1',to:'q2',symbol:'a'},{from:'q1',to:'q2',symbol:'b'},
      {from:'q2',to:'q0',symbol:'a'},{from:'q2',to:'q0',symbol:'b'}
    ]
  },
  mod3_1: {
    description: `Accept all strings of length ≡ 1 (mod 3).`,
    guide: [
      "Step 1: States q0 (0 mod 3), q1 (1 mod 3), q2 (2 mod 3).",
      "Step 2: q0 is start, q1 is accept. On each input move to next mod-3 state.",
      "Step 3: Accept only in q1."
    ],
    states: [{id:'q0'},{id:'q1',accept:1},{id:'q2'}],
    initial:'q0',
    alpha: ['a','b'],
    transitions:[
      {from:'q0',to:'q1',symbol:'a'},{from:'q0',to:'q1',symbol:'b'},
      {from:'q1',to:'q2',symbol:'a'},{from:'q1',to:'q2',symbol:'b'},
      {from:'q2',to:'q0',symbol:'a'},{from:'q2',to:'q0',symbol:'b'}
    ]
  },
  containsAB: {
    description: `Accept strings containing 'ab'.`,
    guide: [
      "Step 1: q0=start, haven't seen 'ab' yet. q1=last was 'a'. q2=seen 'ab' (accept).",
      "Step 2: q0: 'a'→q1, 'b'→q0. q1: 'a'→q1, 'b'→q2. q2: all inputs stay in q2."
    ],
    states: [{id:'q0'},{id:'q1'},{id:'q2',accept:1}],
    initial:'q0',
    alpha:['a','b'],
    transitions:[
      {from:'q0',to:'q1',symbol:'a'},{from:'q0',to:'q0',symbol:'b'},
      {from:'q1',to:'q1',symbol:'a'},{from:'q1',to:'q2',symbol:'b'},
      {from:'q2',to:'q2',symbol:'a'},{from:'q2',to:'q2',symbol:'b'}
    ]
  },
  notContainsAA: {
    description: `Accept strings NOT containing 'aa'.`,
    guide: [
      "Step 1: q0=start, no last 'a'. q1=just seen 'a'.",
      "Step 2: q0: 'a'→q1, 'b'→q0. q1: 'a'→trap(q2), 'b'→q0. q2: sink.",
      "Step 3: q0/q1 accept, q2 does not."
    ],
    states: [{id:'q0',accept:1},{id:'q1',accept:1},{id:'q2'}],
    initial:'q0',
    alpha:['a','b'],
    transitions:[
      {from:'q0',to:'q1',symbol:'a'},{from:'q0',to:'q0',symbol:'b'},
      {from:'q1',to:'q2',symbol:'a'},{from:'q1',to:'q0',symbol:'b'},
      {from:'q2',to:'q2',symbol:'a'},{from:'q2',to:'q2',symbol:'b'}
    ]
  },
  universal: {
    description: `Every string is accepted.`,
    guide: [
      "Step 1: DFA with one state (start/accept), selfloops on all symbols."
    ],
    states:[{id:'q0',accept:1}],
    initial:'q0',
    alpha:['a','b'],
    transitions:[
      {from:'q0',to:'q0',symbol:'a'},{from:'q0',to:'q0',symbol:'b'}
    ]
  },
  empty: {
    description: `No string is accepted.`,
    guide: [
      "Step 1: DFA with one state (start), no accept, selfloops on all symbols."
    ],
    states:[{id:'q0'}],
    initial:'q0',
    alpha:['a','b'],
    transitions:[
      {from:'q0',to:'q0',symbol:'a'},{from:'q0',to:'q0',symbol:'b'}
    ]
  },
  composite1: {
    description: `Accept strings that start with 'a' AND length ≡ 1 mod 3.`,
    guide: [
      "Step 1: Build cross-product of 'start with a' and 'mod 3 = 1' states.",
      "Step 2: Accepting state is (started w/ 'a', mod 3 = 1).",
      "Step 3: Shown using pairs qxy: x for start, y for mod."
    ],
    states:[
      {id:"q00"},{id:"q01",accept:1},{id:"q02"},
      {id:"q10"},{id:"q11"},{id:"q12"},
      {id:"q20"},{id:"q21"},{id:"q22"},
    ],
    initial:'q00',
    alpha:['a','b'],
    transitions:[
      // 'a' from q00 (not started, mod 0) → start, mod 1
      {from:'q00',to:'q01',symbol:'a'},
      // 'b' from q00 → trap, mod 1
      {from:'q00',to:'q21',symbol:'b'},
      // repeat all cases, for brevity only some shown
      {from:'q01',to:'q02',symbol:'a'},{from:'q01',to:'q22',symbol:'b'},
      {from:'q02',to:'q00',symbol:'a'},{from:'q02',to:'q20',symbol:'b'},
      // q21 etc.. are traps etc.
      {from:'q21',to:'q21',symbol:'a'},{from:'q21',to:'q21',symbol:'b'},
      {from:'q22',to:'q22',symbol:'a'},{from:'q22',to:'q22',symbol:'b'},
      {from:'q20',to:'q21',symbol:'b'},{from:'q20',to:'q01',symbol:'a'},
      {from:'q01',to:'q02',symbol:'a'},{from:'q01',to:'q22',symbol:'b'},
      {from:'q10',to:'q11',symbol:'a'},{from:'q10',to:'q21',symbol:'b'},
      {from:'q11',to:'q12',symbol:'a'},{from:'q11',to:'q22',symbol:'b'},
      {from:'q12',to:'q10',symbol:'a'},{from:'q12',to:'q20',symbol:'b'},
      {from:'q21',to:'q21',symbol:'a'},{from:'q21',to:'q21',symbol:'b'},
      {from:'q22',to:'q22',symbol:'a'},{from:'q22',to:'q22',symbol:'b'}
    ]
  },
  composite2: {
    description:`Accepts strings that either end with 'b' OR contain 'ab'.`,
    guide:[
      "Step 1: Use union of 'end b' and 'contains ab' (accept if either DFA accepts).",
      "Step 2: DFA is large (not fully expanded here), shown for reference."
    ],
    states:[
      {id:"p0"},{id:"p1",accept:1},{id:"q0"},{id:"q1"},{id:"q2",accept:1}
    ],
    initial:"p0",
    alpha:['a','b'],
    transitions:[
      {from:"p0",to:"p0",symbol:"a"},{from:"p0",to:"p1",symbol:"b"},
      {from:"p1",to:"p0",symbol:"a"},{from:"p1",to:"p1",symbol:"b"},
      {from:"q0",to:"q1",symbol:"a"},{from:"q0",to:"q0",symbol:"b"},
      {from:"q1",to:"q1",symbol:"a"},{from:"q1",to:"q2",symbol:"b"},
      {from:"q2",to:"q2",symbol:"a"},{from:"q2",to:"q2",symbol:"b"}
    ]
  }
};

const POSITIONS = [
  // up to 9 states, visually spaced
  [{x:150,y:160}], //1
  [{x:110,y:160},{x:290,y:160}], //2
  [{x:80, y:160},{x:210, y:75},{x:340,y:160}], //3
  [{x:70, y:120},{x:70, y:220},{x:330, y:120},{x:330, y:220}], //4
  [{x:80, y:80},{x:80, y:240},{x:320, y:80},{x:320, y:240},{x:200,y:160}], //5
  [{x:60, y:60},{x:60, y:260},{x:200, y:60},{x:200,y:260},{x:340, y:60},{x:340,y:260}], //6
  [{x:60, y:80},{x:60, y:240},{x:200, y:80},{x:200, y:240},{x:340, y:80},{x:340, y:240},{x:200,y:160}], //7
  [{x:50,y:60},{x:50,y:260},{x:170,y:60},{x:170,y:260},{x:290, y:60},{x:290,y:260},{x:410,y:60},{x:410,y:260}], //8
  [{x:45,y:45},{x:45,y:275},{x:158,y:45},{x:158, y:275},{x:271,y:45},{x:271, y:275},{x:384, y:45},{x:384, y:275},{x:215,y:160}] //9
];

// --- Drawing ---
const svg = document.getElementById('dfaSVG');

function clearSVG() {
  svg.innerHTML = '';
}

function drawDFA(dfa, highlight={}) {
  clearSVG();

  // Marker
  const defs = document.createElementNS("http://www.w3.org/2000/svg","defs");
  const marker = document.createElementNS('http://www.w3.org/2000/svg','marker');
  marker.setAttribute('id','arr');
  marker.setAttribute('markerWidth','10');
  marker.setAttribute('markerHeight','10');
  marker.setAttribute('refX','10');
  marker.setAttribute('refY','3.5');
  marker.setAttribute('orient','auto');
  const path = document.createElementNS('http://www.w3.org/2000/svg','path');
  path.setAttribute('d','M0,0 L10,3.5 L0,7 Z');
  path.setAttribute('fill','#4a90e2');
  marker.appendChild(path);
  defs.appendChild(marker);
  svg.appendChild(defs);

  // Layout states nicely
  const n = dfa.states.length;
  const poslist = POSITIONS[n] || POSITIONS[POSITIONS.length-1];
  const statePos = {};
  dfa.states.forEach((s,i) => {
    let {x,y} = poslist[i];
    x += 220; y += 0; // shift visually
    statePos[s.id] = {x, y};
  });
  // Draw transitions (arrows)
  for (const t of dfa.transitions) {
    let {from, to, symbol} = t;
    const highlightArrow = highlight.transitionArrow && highlight.transitionArrow.from===from && highlight.transitionArrow.to===to && highlight.transitionArrow.symbol===symbol;
    if (from !== to) {
      drawArrow(statePos[from], statePos[to], symbol, highlightArrow);
    } else {
      drawSelfLoop(statePos[from], symbol, highlightArrow);
    }
  }
  // Draw states
  dfa.states.forEach(s => {
    const {x, y} = statePos[s.id];
    drawState(x, y, s.id, 
      dfa.initial===s.id,
      !!s.accept,
      highlight.activeState===s.id
    );
  });
  // Draw state labels again for clarity
  dfa.states.forEach(s => {
    const {x, y} = statePos[s.id];
    drawStateLabel(x, y, s.id);
  });

  // Return position mapping for use in animation
  return statePos;
}

function drawArrow(from, to, label, highlight) {
  const dx = to.x - from.x, dy = to.y - from.y;
  const len = Math.sqrt(dx*dx + dy*dy);
  const nx = dx/len, ny = dy/len;
  const startX = from.x + nx*30, startY = from.y + ny*30;
  const endX = to.x - nx*30, endY = to.y - ny*30;

  const curve = 0.14*len;
  const c1x = startX + curve*ny, c1y = startY - curve*nx;
  const c2x = endX + curve*ny, c2y = endY - curve*nx;

  const path = document.createElementNS('http://www.w3.org/2000/svg','path');
  path.setAttribute('d',`M${startX},${startY} C${c1x},${c1y} ${c2x},${c2y} ${endX},${endY}`);
  path.setAttribute('class','arrow'+(highlight?' active':''));
  path.setAttribute('marker-end','url(#arr)');
  svg.appendChild(path);

  // Label
  const lm = 0.5;
  const labelX = startX*lm + endX*(1-lm) + curve*ny;
  const labelY = startY*lm + endY*(1-lm) - curve*nx - 8;
  const text = document.createElementNS('http://www.w3.org/2000/svg','text');
  text.textContent = label;
  text.setAttribute('class','transLabel');
  text.setAttribute('x',labelX);
  text.setAttribute('y',labelY);
  svg.appendChild(text);
}
function drawSelfLoop(pos, label, highlight) {
  const {x,y} = pos;
  const r = 30;
  const path = document.createElementNS('http://www.w3.org/2000/svg','path');
  path.setAttribute('d',
    `M${x},${y-r} C${x+36},${y-48},${x-36},${y-48},${x},${y-r}`);
  path.setAttribute('class','selfloop'+(highlight?' active':''));
  svg.appendChild(path);

  // Label
  const text = document.createElementNS('http://www.w3.org/2000/svg','text');
  text.textContent = label;
  text.setAttribute('class','selfloopLabel');
  text.setAttribute('x',x);
  text.setAttribute('y',y-r-27);
  text.setAttribute('text-anchor','middle');
  svg.appendChild(text);
}
function drawState(x,y,id,initial,final,active) {
  const g = document.createElementNS('http://www.w3.org/2000/svg','g');
  if (active) g.style.filter="drop-shadow(0 0 10px #ffd54f)";
  svg.appendChild(g);

  const cir = document.createElementNS('http://www.w3.org/2000/svg','circle');
  cir.setAttribute('cx',x);
  cir.setAttribute('cy',y);
  cir.setAttribute('r',30);
  cir.setAttribute('stroke','#4a90e2');
  cir.setAttribute('stroke-width',final?"4":"2.2");
  cir.setAttribute('fill',active?'#ffd54f':(final?'#eafcf6':'#f5f8fd'));
  g.appendChild(cir);
  if (final) {
    const fc = document.createElementNS('http://www.w3.org/2000/svg','circle');
    fc.setAttribute('cx',x); fc.setAttribute('cy',y);
    fc.setAttribute('r',24);
    fc.setAttribute('stroke','#2ecc71');
    fc.setAttribute('stroke-width',"2.2");
    fc.setAttribute('fill','none');
    g.appendChild(fc);
  }
  if (initial) {
    const arr = document.createElementNS('http://www.w3.org/2000/svg','path');
    arr.setAttribute('d',`M${x-65},${y} L${x-38},${y}`);
    arr.setAttribute('stroke','#e67e22');
    arr.setAttribute('stroke-width',"3");
    arr.setAttribute('marker-end','url(#arr)');
    svg.appendChild(arr);
  }
}
function drawStateLabel(x,y,label) {
  const text = document.createElementNS('http://www.w3.org/2000/svg','text');
  text.textContent = label;
  text.setAttribute('class','stateLabel');
  text.setAttribute('x',x);
  text.setAttribute('y',y+7);
  text.setAttribute('text-anchor','middle');
  svg.appendChild(text);
}

// --- Animation logic ---
let CURRENT_DFA=null, STATE_POS=null, ANIMATION=null;

function loadDFA(type) {
  const preset = DFA_PRESETS[type];
  CURRENT_DFA = preset;
  guide.innerHTML = `<b>${preset.description}</b><br>${preset.guide.map(x=>'<div>'+x+'</div>').join('')}`;
  STATE_POS = drawDFA(preset,{});
  output.textContent='';
}
dfaType.onchange = e=>{
  if (!dfaType.value) { guide.innerHTML="Select a DFA type to see construction steps and run animation."; clearSVG(); output.textContent=''; return; }
  loadDFA(dfaType.value);
};

function* animateTraverse(dfa, input) {
  let curr = dfa.initial;
  yield {activeState:curr};
  for (let i=0; i<input.length; ++i) {
    const c = input[i];
    let t = dfa.transitions.find(t=>t.from===curr&&t.symbol===c);
    if (!t) {
      yield {activeState:curr, error:`No transition from ${curr} on '${c}'.`};
      return;
    }
    yield {activeState:curr, transitionArrow:t};
    curr = t.to;
    yield {activeState:curr};
  }
  if (dfa.states.find(s=>s.id===curr&&s.accept)) {
    yield {activeState:curr, accept:true};
  } else {
    yield {activeState:curr, reject:true};
  }
}
testBtn.onclick = ()=>{
  if (!CURRENT_DFA) return;
  const input = testStr.value.trim();
  for (let ch of input) if (!CURRENT_DFA.alpha.includes(ch)) {
    output.textContent=`Error: symbol '${ch}' not in {a,b}`;
    return;
  }
  // reset and draw
  ANIMATION=animateTraverse(CURRENT_DFA, input);
  nextAnimStep();
};
function nextAnimStep() {
  if (!ANIMATION) return;
  const {value,done}=ANIMATION.next();
  if (!value) return;
  drawDFA(CURRENT_DFA,value);
  if (value.error) {
    output.textContent=value.error;
    ANIMATION=null; return;
  }
  if (value.accept) { output.textContent="String accepted (in final state)!"; ANIMATION=null; return;}
  if (value.reject) { output.textContent="String rejected (nonfinal state)."; ANIMATION=null; return;}
  if (!ANIMATION || done) return;
  setTimeout(nextAnimStep, 850);
}
resetBtn.onclick = ()=>{
  if (!CURRENT_DFA) return;
  drawDFA(CURRENT_DFA,{});
  output.textContent='';
  ANIMATION=null;
};

// Load first DFA for instant preview
dfaType.value = '';
clearSVG();

</script>
</body>
</html>
